# **UBF2D**: a pilot research code for the aerodynamic force analysis

The following description is not intended as a code reference guide or detailed documentation manual. Instead, it offers an overview on the main features of the software and briefly describes the numerical receipts used in the implementation.

**Unsteady Break-Force 2D** (**UBF2D**) is a pilot two-dimensional code developed by the <ins>*Italian Aerospace Research Centre*</ins> (*CIRA*) and the <ins>*University of Naples Federico II*</ins>, for the analysis and decomposition of the aerodynamic force on clean aerofoils.
It is written in *C++* (roughly 8300 code lines) and uses the public-domain [*TecIO* library](https://tecplot.com/products/tecio-library/) to manage input and output of structured datasets[^1].

[^1]: Incidentally, during the initial developing phase, a bug was found in the TecIO library (version 2021, release 1), related to writing out cell-centred data in structured blocks. It was reported to *Tecplot Inc.* and subsequently fixed in the following releases of the library.

The code is able to post-process a steady or unsteady 2D flow-field, where data are provided in dimensional form (International System of Units) at grid nodes of a structured C-mesh (organised in one or multiple blocks, clock-wise-oriented along the C-direction). **UBF2D** reads in solution input files, together with a case configuration file (containing asymptotic conditions, reference values, mesh movement specification, numerical settings, etc.).

The accepted solution input format is given by *Tecplot sub-zone* (load-on-demand) binary files (one file for each solution time) containing at least primitive variables data and grid velocities.
Indeed, either fixed or moving meshes are considered, where harmonic pitching and/or plunging oscillations may be prescribed.
Similarly, the code is able to deal with either viscous or inviscid solutions, obtained from compressible or incompressible flow solvers.

The aerodynamic force is internally computed using both near-field and far-field formulations, ensuring coherence of the adopted gradient schemes and working variables allocation necessary to fairly compare the two force results.
Different far-field formulations are implemented and available to the user: steady thermodynamic methods from [Destarac and van der Vooren](https://doi.org/10.1016/j.ast.2004.03.004)  and from [Paparone and Tognaccini](https://doi.org/10.2514/2.7300); several Lamb-vector-based methods developed in the last decades (a summary is provided by [Minervino and Tognaccini](https://doi.org/10.1016/j.ast.2023.108674)) and applicable to inertial or non-inertial reference frames. For incompressible flows, the mixed inertial\slash non-inertial described in [Sticchi et al.](https://doi.org/10.2514/6.2023-4090) is also available. Unsteady terms can be computed in the standard or in the alternative way (see [Minervino and Tognaccini](https://doi.org/10.1108/HFF-06-2023-0350)}) and the compressibility correction by [Mele et al.](https://doi.org/10.1063/1.4875015) can be computed using any of the three mathematically equivalent formulations provided by the authors.
The Lamb vector can be computed in two different ways, i.e. by its vortical or thermodynamic definitions ([Minervino and Tognaccini](https://doi.org/10.1063/5.0164384)), then the new exact force formula derived in [Minervino and Tognaccini](https://doi.org/10.1063/5.0164384) is also implemented in the code.

The integration domain used by far-field force methods is always selected as a sub-set of the input grid (identified by three orthogonal grid lines of the C-mesh around the aerofoil) and can be parametrically modified to allow for far-field force analysis on variable control volumes. 

**UBF2D** provides three different options for the computation of spatial gradients from discrete structured data-sets:
+ a nodes-based Green-Gauss (G-G) formula, with results allocated at cells-centres.
+ 2<sup>nd</sup>-order finite differences in the computational space associated to the physical curvilinear grid, using nodal values of the working variables (asymmetric stencils are used at grid boundaries to preserve accuracy) and allocating gradient data at grid nodes.
+ a Weighted Least Squares (WLS) method, based on cell-centres data and allocating results at cells centres as well. Ghost cells are used at grid boundaries with appropriate values of the working variables.
The last two methods are discrete gradient approximations with step *h*, where *h* is the generic mesh spacing. The nodes-based G-G method, for curvilinear grids, degenerates to the finite differences scheme with step *h/2*. A detailed discussion on the numerical accuracy of the implemented gradient reconstruction methods can be found in [Sozer et al.](https://doi.org/10.2514/6.2014-1440).

Time derivatives were always computed using a 2<sup>nd</sup>-order central finite differences scheme, with asymmetric stencils adopted at time domain boundaries to preserve accuracy.

Volume integrals are numerically computed by simply summing-up cell centre values, multiplied by the cell volume, over the selected integration domain. Similarly, surface integrals are obtained computing the state in the cell surface centre, which can be either obtained by centred averaging based on face nodes, or by linear interpolation of cell-centred values from adjacent cells[^2].
[^2]: In the text, a general three-dimensional nomenclature is used, despite **UFB2D** being a 2D code. In this case, obviously, "volumes" should be intended as "areas", "faces" as "edges", and so on.

Different regions can be identified in the integration domain and used for parasite drag decomposition. This is performed by either using deterministic sensors or by supplying external information (provided as cells flagging, in the solution input files), which may come, for example, from other codes using machine learning approaches to separate different regions in the flow-field (this was done in [Saetta et al.](https://hdl.handle.net/11588/916288), where **UFB2D** was used in combination with an auto-encoder, performing the domain decomposition).
In the first approach, the shock sensor defined by [Lovely and Haimes](https://doi.org/10.2514/6.1999-3285) is used, together with two viscous sensors, designed for fully turbulent flows: i) an eddy viscosity sensor ($F_{bl}=\left(\mu+\mu_{t}\right) / \mu$), which assumes values significantly higher than 1 in the boundary layer and in the viscous wake (see [Tognaccini, R.](https://hdl.handle.net/11588/176413) and [Paparone and Tognaccini](https://doi.org/10.2514/2.7300)); ii) turbulence specific dissipation rate ($\omega$), assuming very high values near the body surface and, in particular, in the viscous sub-layer, where the eddy viscosity vanishes. The user can supply appropriate sensor cut-off values in the configuration file.

The code provides screen output (including case settings, near-field pressure and viscous forces, far-field forces obtained by different formulations and their complete decomposition) as well as Tecplot binary output (sub-zone load-on-demand file, containing input and computed variables, including near-field and far-field aerodynamic forces, calculated on all specified integration domains). For unsteady post-processing, a time history file including the main force results is also generated for the user's convenience.
